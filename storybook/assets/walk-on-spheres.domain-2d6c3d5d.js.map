{"version":3,"file":"walk-on-spheres.domain-2d6c3d5d.js","sources":["../../../examples/dist/walk-on-spheres/walk-on-spheres.style.js","../../../examples/dist/walk-on-spheres/walk-on-spheres.domain.js"],"sourcesContent":["import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"walk-on-spheres\");\nexport default \"-- diagram dimensions (in px)\\ncanvas {\\n   width = 320\\n   height = 240\\n}\\n\\n-- some colors re-used throughout\\nColors {\\n   color black = rgba(0,0,0,1)\\n   color white = rgba(1,1,1,1)\\n   color darkGray = rgba(.5,.5,.5,1)\\n   color lightGray = rgba(.9,.9,.9,1)\\n}\\n\\n-- global shapes and constants\\nGlobal {\\n   -- default appearance for label text\\n   string labelFont = \\\"Palatino\\\"\\n   string labelSize = \\\"12px\\\"\\n   color labelColor = Colors.black\\n\\n   -- line thickness for basic shapes\\n   scalar sphereStrokeWidth = 1.5\\n   scalar domainStrokeWidth = 2\\n\\n\\n   -- invisible box around the canvas (used for reference/constraints)\\n   shape box = Rectangle {\\n      center: (0,0)\\n      width: canvas.width\\n      height: canvas.height\\n      fillColor: none()\\n      strokeColor: none()\\n   }\\n\\n   -- draw the domain as a polygon with some random variation, by\\n   -- perturbing the vertices of a hexagon by some bounded amount\\n   -- Note: if the domain shape is changed to something else (like\\n   -- an ellipse or a rectangle), things _should_ still work as\\n   -- expected, since later methods just make a call to `signedDistance`\\n   -- to determine ball radii.  However, signed distance may not yet\\n   -- be supported for all shapes (like arbitrary Bézier curves).\\n   vec2 p0 = (?,?)\\n   vec2 p1 = (?,?)\\n   vec2 p2 = (?,?)\\n   vec2 p3 = (?,?)\\n   vec2 p4 = (?,?)\\n   vec2 p5 = (?,?)\\n   scalar maxPerturbation = 30.\\n   ensure lessThan( norm(p0), maxPerturbation )\\n   ensure lessThan( norm(p1), maxPerturbation )\\n   ensure lessThan( norm(p2), maxPerturbation )\\n   ensure lessThan( norm(p3), maxPerturbation )\\n   ensure lessThan( norm(p4), maxPerturbation )\\n   ensure lessThan( norm(p5), maxPerturbation )\\n   shape domain = Polygon {\\n      points: ( (150,-110)+p0, (0,-110)+p1, (-150,-110)+p2, (-150,110)+p3, (0,110)+p4, (150,110)+p5)\\n      fillColor: Colors.lightGray\\n      strokeColor: Colors.darkGray\\n      strokeWidth: Global.domainStrokeWidth\\n      ensureOnCanvas: false\\n   }\\n   ensure contains( Global.box, Global.domain ) -- make sure the domain shape stays on the canvas\\n   layer box below domain\\n}\\n\\n-- label the domain if it was assigned a label in the Substance program\\nforall Domain U\\nwhere U has label {\\n   shape U.labelText = Text {\\n      string: U.label\\n      center: (?,?)\\n      fontSize: Global.labelSize\\n      fontFamily: Global.labelFont\\n      fillColor: Colors.darkGray\\n   }\\n\\n   ensure lessThan( signedDistance( Global.domain, U.labelText.center ), -10. )\\n\\n   layer U.labelText above Global.domain -- make sure the label doesn't get covered by the domain shape\\n}\\n\\n-- draw each step of a walk as a ball tangent to the domain boundary\\nforall Step s {\\n\\n   -- The `ball` shape is a flat-shaded semi-transparent\\n   -- disk that determines the color of the ball; its center\\n   -- and radius are used as a reference for all other shapes\\n   -- related to this ball.  Note that we don't need to\\n   -- explicitly enforce that the ball remains on the canvas,\\n   -- since the domain shape already has an onCanvas constraint,\\n   -- and the balls are always contained in the domain shape, by\\n   -- construction.\\n   shape s.ball = Circle {\\n      center: (?,?)\\n      fillColor: rgba( .2, .8, .2, .15 )\\n      strokeColor: none()\\n      ensureOnCanvas: false\\n   }\\n\\n   -- Make sure that the ball center is inside the problem domain.\\n   scalar R = signedDistance( Global.domain, s.ball.center )\\n   ensure lessThan( R, 0. )\\n\\n   -- Also set the ball radius equal to the distance from the\\n   -- ball center to the closest point on the domain boundary\\n   -- (just as in the WoS algorithm!).  We also subtract half\\n   -- the stroke widths,\\n   s.ball.r = -R - Global.sphereStrokeWidth/2 - Global.domainStrokeWidth/2.\\n\\n   -- The `sphere` shape represents the boundary of the ball,\\n   -- and is drawn as an empty circle with a thick line.\\n   shape s.sphere = Circle {\\n      center: s.ball.center\\n      r: s.ball.r\\n      fillColor: none()\\n      strokeColor: rgba( .4, .5, .4, 1 )\\n      strokeWidth: Global.sphereStrokeWidth\\n      ensureOnCanvas: false\\n   }\\n\\n   -- The `dot` shape represents the sample point associated\\n   -- with the ball.  Ordinarily this point will be at the\\n   -- center of the ball, but in general it could be at a\\n   -- different location (e.g., for an off-center walk).\\n   shape s.dot = Circle {\\n      center: s.ball.center\\n      r: 2.5\\n      fillColor: Colors.black\\n      ensureOnCanvas: false\\n   }\\n\\n   -- To give the balls a three-dimensional appearance, blend\\n   -- a shading image behind the flat colored disk.\\n   shape s.shading = Image {\\n      center: s.ball.center \\n      width: s.ball.r * 2.0\\n      height: s.ball.r * 2.0\\n      href: \\\"walk-on-spheres-ball.svg\\\"\\n      ensureOnCanvas: false\\n   }\\n\\n   -- Make sure all components of the ball get drawn in the\\n   -- proper order, and are not covered up by the domain shape.\\n   layer s.shading above Global.domain\\n   layer s.ball above s.shading\\n   layer s.sphere above s.ball\\n   layer s.dot above s.ball\\n\\n   -- This constant will be used to determine how much balls\\n   -- shrink from one step of the walk to the next.  We define\\n   -- it here so that specialized types of balls (say, those\\n   -- coming from a nested walk) can use a different factor.\\n   scalar s.shrinkFactor = .55\\n}\\n\\n-- Make sure the domain's label isn't covered up by a ball.\\nforall Step x; Domain U\\nwhere U has label {\\n   ensure disjoint( U.labelText, x.sphere, 10. )\\n}\\n\\n\\n-- For a step of an off-centered walk, we want to clearly\\n-- indicate that the sample point may not be at the ball center.\\nforall Step s\\nwhere offCenter(s) {\\n\\n   -- We can no longer just copy the dot center from the ball center,\\n   -- but will instead let the layout engine figure out its location.\\n   override s.dot.center = (?,?)\\n\\n   -- Still keep the center within the middle 75% of the ball, since\\n   -- the dot may be hard to see if it gets too close to the boundary\\n   -- (especially for very small balls).\\n   ensure lessThan( norm(s.dot.center-s.ball.center), .75*s.ball.r )\\n}\\n\\n-- If the step has a label, draw a label string near the sample point.\\nforall Step s\\nwhere s has label {\\n   shape s.labelText = Text {\\n      string: s.label\\n      center: (?,?) -- the layout engine will determine the exact placement\\n      fontSize: Global.labelSize\\n      fontFamily: Global.labelFont\\n      fontStyle: \\\"italic\\\"\\n      fillColor: Global.labelColor\\n      strokeColor: Colors.white\\n      strokeWidth: 2.5\\n      strokeLinejoin: \\\"round\\\"\\n      paintOrder: \\\"stroke\\\"\\n   }\\n\\n   -- We want the label to be near the dot, but don't want it\\n   -- to overlap the dot (which makes it hard to read).\\n   encourage near( s.labelText, s.dot )\\n   ensure disjoint( s.labelText, s.dot, 2. )\\n\\n   -- Make sure the label doesn't get covered by the ball or\\n   -- its boundary by layering it above the topmost shape.\\n   layer s.labelText above s.sphere\\n}\\n\\n-- Draw steps that belong to a nested walk in a different style.\\nforall Step s\\nwhere nested( s ) {\\n   -- Change to a color palette that is more white & opaque.\\n   override s.ball.fillColor = rgba( 1, 1, 1, .4 )\\n   override s.dot.fillColor = Colors.white\\n   override s.sphere.strokeColor = Colors.white\\n\\n   -- Since nested walks are usually secondary in the overall\\n   -- diagram, draw them smaller by making them shrink faster.\\n   override s.shrinkFactor = .7\\n}\\n\\n-- If a step x1 is sampled from the boundary of another step x0,\\n-- draw the sample point on the sphere around x0.\\nforall Step x0; Step x1\\nwhere x1 := sampleBoundary(x0) {\\n\\n   ensure equal( norm(x1.dot.center-x0.ball.center), x0.ball.r )\\n\\n   -- draw later steps of the walk as smaller\\n   -- balls (which will typically, but not always,\\n   -- be the behavior of the WoS algorithm)\\n   ensure equal( x1.ball.r, x1.shrinkFactor * x0.ball.r )\\n\\n   -- It's typically easier to see labels, etc., if later, smaller\\n   -- balls are drawn on top of earlier, bigger ones.\\n   layer x1.shading above x0.sphere\\n\\n   -- Also draw a line between the sample points, to help\\n   -- illustrate the path along the walk.\\n   color walkColor = rgba( 0, 0, .7, 1 )\\n   shape walkLine = Line {\\n      start: x0.dot.center\\n      end: x1.dot.center\\n      strokeWidth: 2.\\n      strokeColor: walkColor\\n   }\\n   layer walkLine above Global.domain\\n\\n   -- Use layering to help clarify the direction of the\\n   -- walk, by always drawing the line above x0 and below x1.\\n   layer walkLine above x0.shading\\n   layer walkLine below x1.shading\\n}\\n\\n-- The next step in a walk might also be sampled from\\n-- the ball interior (e.g., to estimate a value expressed\\n-- in terms of a source term).\\nforall Step y; Step x\\nwhere y := sampleInterior( x ) {\\n\\n   -- Put the center of the next ball somewhere inside\\n   -- the current ball, between 20% and 80% of the\\n   -- radial distance from the center.\\n   scalar R = norm(y.dot.center-x.ball.center)\\n   scalar r = x.ball.r\\n   ensure inRange( R, .2*r, .8*r )\\n\\n   -- Since these samples tend to be the start of a\\n   -- secondary, \\\"nested\\\" walk, we'll draw this ball\\n   -- much smaller than its parent in the walk.\\n   ensure equal( y.ball.r, .1 * x.ball.r )\\n\\n   -- Make sure the smaller ball gets drawn on top\\n   -- of the bigger ball by putting the lowest layer\\n   -- of the former above the highest layer of the latter.\\n   layer y.shading above x.sphere\\n}\\n\\n-- Draw sample points that are used to estimate the source term\\n-- as just dots contained in the ball of interest.  These sample\\n-- points are different from steps of a walk, since we never\\n-- need to consider a ball around these points (and hence do not\\n-- want to draw one).\\nforall Sample p; Step x\\nwhere p := sampleSource( x ) {\\n\\n   shape p.dot = Circle {\\n      center: (?,?)\\n      r: 2\\n      fillColor: Colors.white\\n      strokeColor: Colors.black\\n      strokeWidth: 1\\n   }\\n\\n   -- Put the sample point somewhere between 20% and\\n   -- 80% away from the center, so that it's clearly visible\\n   -- and doesn't run into the center point or the boundary.\\n   scalar R = norm( p.dot.center - x.ball.center )\\n   scalar r = x.ball.r\\n   ensure inRange( R, .2*r, .8*r )\\n\\n   -- Make sure the dot is not covered by the ball.\\n   layer p.dot above x.ball\\n}\\n\\n-- Label a sample point if it a label string was specified\\n-- in the Substance program.\\nforall Sample p\\nwhere p has label {\\n   shape p.labelText = Text {\\n      string: p.label\\n      center: (?,?)\\n      fontSize: Global.labelSize\\n      fontFamily: Global.labelFont\\n      fontStyle: \\\"italic\\\"\\n      fillColor: Global.labelColor\\n      strokeColor: Colors.white\\n      strokeWidth: 2.5\\n      strokeLinejoin: \\\"round\\\"\\n      paintOrder: \\\"stroke\\\"\\n   }\\n\\n   -- Put the label near the dot, but don't allow\\n   -- it to cover up the dot (or vice versa).\\n   encourage near( p.labelText, p.dot )\\n   ensure disjoint( p.labelText, p.dot, 2. )\\n}\\n\\n-- If this sample was drawn from a ball around x,\\n-- make sure the sample's label is drawn on top\\n-- of that ball.\\nforall Sample y; Step x\\nwhere y has label; y := sampleSource(x) {\\n   layer y.labelText above x.sphere\\n}\\n\\n-- Also make sure the sample point isn't covered\\n-- by the next or previous shading in the walk\\nforall Step x0; Step x1; Sample y0\\nwhere x1 := sampleBoundary(x0); y0 := sampleSource(x0) {\\n   ensure disjoint( x1.sphere, y0.dot )\\n}\\nforall Step x0; Step x1; Sample y1\\nwhere x1 := sampleBoundary(x0); y1 := sampleSource(x1) {\\n   ensure disjoint( x0.sphere, y1.dot )\\n}\\n\\n\";\n//# sourceMappingURL=walk-on-spheres.style.js.map","export default \"type Domain -- a region in ℝⁿ\\ntype Step -- a step in a walk\\ntype Sample -- a sample point used for an estimator\\n\\n-- x1 := sampleBoundary(x0) takes a step in the walk by sampling the boundary\\nconstructor sampleBoundary( Step x0 ) -> Step x1\\n\\n-- y1 := sampleInterior(x0) takes a step in the walk by sampling the interior\\nconstructor sampleInterior( Step x0 ) -> Step y1\\n\\n-- y1 := sampleSource(x0) samples a source in the interior, but does not start a new walk\\nconstructor sampleSource( Step x0 ) -> Sample y1\\n\\n-- nested(x) asserts that step x belongs to a nested walk,\\n-- e.g., a walk that begins at a source sample point and then\\n-- continues all the way to the boundary\\npredicate nested( Step x )\\n\\n-- offCenter(x) asserts that step x is an off-centered step,\\n-- which need not be placed at the center of the ball\\npredicate offCenter( Step x )\\n\\n\";\n//# sourceMappingURL=walk-on-spheres.domain.js.map"],"names":["resolver","makeResolver","style0","domain"],"mappings":"2CACY,MAACA,EAAWC,EAAa,iBAAiB,EACtDC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECFfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;"}