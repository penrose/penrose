-- Based on the "dinoshade" OpenGL example by Mark J. Kilgard

canvas {
   width = 1920
   height = 1080
}

global {
   scalar angle = -150 -- in degrees
   scalar W = 300
   scalar H = 300

   vec4 lightZeroPosition = ( 10.0, 4.0, 10.0, 1.0 )
   color lightZeroColor = ( 0.8, 1.0, 0.8, 1.0 ) -- green tinted
   vec4 lightOnePosition = ( -1.0, -2.0, 1.0, 0.0 )
   vec4 lightOneColor = ( 0.6, 0.3, 0.2, 1.0 ) -- red tinted
   vec4 skinColor = ( 0.1, 1.0, 0.1, 1.0 )
   color eyeColor = ( 1.0, 0.2, 0.2, 1.0 )

   shape title = Text {
      string: "Leaping Lizards!"
   }
}

camera {
  -- -- set camera viewpoint
  -- vec3 eye = (0,0,30)
  -- vec3 center = (0,0,0)
  -- vec3 up = (0,1,0) -- up is in positive Y direction
  -- mat4x4 model = lookAt( eye, center, up )

  -- -- set camera projection
  -- scalar fovy = 40 -- field of view in degrees
  -- scalar aspect = canvas.width / canvas.height -- aspect ratio
  -- scalar near = 1.0 -- Z near
  -- scalar far = 40.0 -- Z far
  -- mat4x4 proj = perspective( fovy, aspect, near, far )

  -- -- mat4x4 A = proj
  -- -- vec2 t = ( canvas.width, -canvas.height ) / 2
  -- -- shape debug = Polyline {
  -- --    points: [  (A[0][0], A[0][1]) - t, (A[0][2], A[0][3]) - t, (A[1][0], A[1][1]) - t, (A[1][2], A[1][3]) - t, (A[2][0], A[2][1]) - t, (A[2][2], A[2][3]) - t, (A[3][0], A[3][1]) - t, (A[3][2], A[3][3]) - t ]
  -- -- }

  -- list view = [ -canvas.width/2, -canvas.height/2, canvas.width, canvas.height ]

     -- XXX camera matrices above are giving INF/NaN...

   -- define the camera viewpoint
   vec3 eye = 4.5*(1,1,1)
   vec3 center = (0,0,0)
   vec3 up = (0,1,0)
   mat4x4 model = lookAt( eye, center, up )

   -- define the camera projection
   scalar fovy = 40 -- degrees
   scalar aspect = canvas.width / canvas.height
   scalar near = 0.1
   scalar far = 100.0
   mat4x4 proj = perspective( fovy, aspect, near, far )

   -- define the canvas / "viewport"
   list view = [ -canvas.width/2, -canvas.height/2, canvas.width, canvas.height ]
}

lizard {
   scalar bodyWidth = 2.0
   scalar angle = random(0,2) * MathPI()
   mat4x4 model = translate3dh(-8,-8,-bodyWidth/2) then rotate3dh( angle, (0,1,0) )

   list body = [ (0, 3, 0), (1, 1, 0), (5, 1, 0), (8, 4, 0), (10, 4, 0), (11, 5, 0), (11, 11.5, 0), (13, 12, 0), (13, 13, 0), (10, 13.5, 0), (13, 14, 0), (13, 15, 0), (11, 16, 0), (8, 16, 0), (7, 15, 0), (7, 13, 0), (8, 12, 0), (7, 11, 0), (6, 6, 0), (4, 3, 0), (3, 2, 0), (1, 2, 0) ] -- 22
   list arm  = [ (8, 10, 0), (9, 9, 0), (10, 9, 0), (13, 8, 0), (14, 9, 0), (16, 9, 0), (15, 9.5, 0), (16, 10, 0), (15, 10, 0), (15.5, 11, 0), (14.5, 10, 0), (14, 11, 0), (14, 10, 0), (13, 9, 0), (11, 11, 0), (9, 11, 0) ] -- 16
   list leg  = [ (8, 6, 0), (8, 4, 0), (9, 3, 0), (9, 2, 0), (8, 1, 0), (8, 0.5, 0), (9, 0, 0), (12, 0, 0), (10, 1, 0), (10, 2, 0), (12, 4, 0), (11, 6, 0), (10, 7, 0), (9, 7, 0) ] -- 14
   list eye  = [ (8.75, 15, 0), (9, 14.7, 0), (9.6, 14.7, 0), (10.1, 15, 0), (9.6, 15.25, 0), (9, 15.25, 0) ] -- 6

   shape bodyP = Polygon {
      points: projectList( body, camera.model, camera.proj, camera.view )
   }
   shape armP = Polygon {
      points: projectList( arm, camera.model, camera.proj, camera.view )
   }
   shape legP = Polygon {
      points: projectList( leg, camera.model, camera.proj, camera.view )
   }
   shape eyeP = Polygon {
      points: projectList( eye, camera.model, camera.proj, camera.view )
   }
}

-- void
-- extrudeSolidFromPolygon(GLfloat data[][2], unsigned int dataSize,
--   GLdouble thickness, GLuint side, GLuint edge, GLuint whole)
-- {
--   static GLUtriangulatorObj *tobj = NULL;
--   GLdouble vertex[3], dx, dy, len;
--   int i;
--   int count = dataSize / (int) (2 * sizeof(GLfloat));
-- 
--   if (tobj == NULL) {
--     tobj = gluNewTess();  /* create and initialize a GLU
--                              polygon tesselation object */
--     gluTessCallback(tobj, GLU_BEGIN, (void (CALLBACK*)()) glBegin);
--     gluTessCallback(tobj, GLU_VERTEX, (void (CALLBACK*)()) glVertex2fv);  /* semi-tricky */
--     gluTessCallback(tobj, GLU_END, (void (CALLBACK*)()) glEnd);
--   }
--   glNewList(side, GL_COMPILE);
--   glShadeModel(GL_SMOOTH);  /* smooth minimizes seeing
--                                tessellation */
--   gluBeginPolygon(tobj);
--   for (i = 0; i < count; i++) {
--     vertex[0] = data[i][0];
--     vertex[1] = data[i][1];
--     vertex[2] = 0;
--     gluTessVertex(tobj, vertex, data[i]);
--   }
--   gluEndPolygon(tobj);
--   glEndList();
--   glNewList(edge, GL_COMPILE);
--   glShadeModel(GL_FLAT);  /* flat shade keeps angular hands
--                              from being "smoothed" */
--   glBegin(GL_QUAD_STRIP);
--   for (i = 0; i <= count; i++) {
--     /* mod function handles closing the edge */
--     glVertex3f(data[i % count][0], data[i % count][1], 0.0);
--     glVertex3f(data[i % count][0], data[i % count][1], thickness);
--     /* Calculate a unit normal by dividing by Euclidean
--        distance. We * could be lazy and use
--        glEnable(GL_NORMALIZE) so we could pass in * arbitrary
--        normals for a very slight performance hit. */
--     dx = data[(i + 1) % count][1] - data[i % count][1];
--     dy = data[i % count][0] - data[(i + 1) % count][0];
--     len = sqrt(dx * dx + dy * dy);
--     glNormal3f(dx / len, dy / len, 0.0);
--   }
--   glEnd();
--   glEndList();
--   glNewList(whole, GL_COMPILE);
--   glFrontFace(GL_CW);
--   glCallList(edge);
--   glNormal3f(0.0, 0.0, -1.0);  /* constant normal for side */
--   glCallList(side);
--   glPushMatrix();
--   glTranslatef(0.0, 0.0, thickness);
--   glFrontFace(GL_CCW);
--   glNormal3f(0.0, 0.0, 1.0);  /* opposite normal for other side */
--   glCallList(side);
--   glPopMatrix();
--   glEndList();
-- }
-- 
-- void
-- makeDinosaur(void)
-- {
--   GLfloat bodyWidth = 3.0;
-- 
--   extrudeSolidFromPolygon(body, sizeof(body), bodyWidth, BODY_SIDE, BODY_EDGE, BODY_WHOLE);
--   extrudeSolidFromPolygon(arm, sizeof(arm), bodyWidth / 4, ARM_SIDE, ARM_EDGE, ARM_WHOLE);
--   extrudeSolidFromPolygon(leg, sizeof(leg), bodyWidth / 2, LEG_SIDE, LEG_EDGE, LEG_WHOLE);
--   extrudeSolidFromPolygon(eye, sizeof(eye), bodyWidth + 0.2, EYE_SIDE, EYE_EDGE, EYE_WHOLE);
-- 
--   glNewList(DINOSAUR, GL_COMPILE);
--   glMaterialfv(GL_FRONT, GL_DIFFUSE, skinColor);
--   glCallList(BODY_WHOLE);
--   glPushMatrix();
--   glTranslatef(0.0, 0.0, bodyWidth);
--   glCallList(ARM_WHOLE);
--   glCallList(LEG_WHOLE);
--   glTranslatef(0.0, 0.0, -bodyWidth - bodyWidth / 4);
--   glCallList(ARM_WHOLE);
--   glTranslatef(0.0, 0.0, -bodyWidth / 4);
--   glCallList(LEG_WHOLE);
--   glTranslatef(0.0, 0.0, bodyWidth / 2 - 0.1);
--   glMaterialfv(GL_FRONT, GL_DIFFUSE, eyeColor);
--   glCallList(EYE_WHOLE);
--   glPopMatrix();
--   glEndList();
-- }

-- void
-- motion(int x, int y)
-- {
--   if (moving) {
--     angle = angle + (x - begin);
--     begin = x;
--     newModel = 1;
--     glutPostRedisplay();
--   }
-- }


-- I guess these could be code blocks to comment/uncomment
-- glutAddMenuEntry("Toggle right light", 1);
-- glutAddMenuEntry("Toggle left light", 2);

