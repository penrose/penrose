canvas {
   width = 240
   height = 200
}

global {
   lineWidth = .65
}

colors {
   color black = #000
   color lightBlue = #cecfe5ee
}

camera {
   -- define the camera viewpoint
   vec3 eye = 100*(1,1,1)
   vec3 center = (0,0,0)
   vec3 up = (0,1,0)
   mat4x4 model = lookAt( eye, center, up )

   -- define the camera projection
   scalar fovy = 40 -- degrees
   scalar aspect = canvas.width / canvas.height
   scalar near = 0.1
   scalar far = 100.0
   mat4x4 proj = perspective( fovy, aspect, near, far )

   -- define the viewport
   list view = [ -canvas.width/2, -canvas.height/2, canvas.width, canvas.height ]
}

-- draw each point as a black dot
forall Point p {
   vec3 p.position = (?,?,?)
   vec2 p.projection = project( p.position, camera.model, camera.proj, camera.view )

   shape p.icon = Circle {
      center: p.projection
      r: 2
      fillColor: #000
      ensureOnCanvas: false
   }
}

-- draw circumcenters as white dots, and
-- place them at the circumcenter of their tet
forall Point p; Tetrahedron t; Point qi, qj, qk, ql
where p := TetCircumcenter( t ); t := Tetrahedron( qi, qj, qk, ql ) {
   override p.icon.fillColor = #fff
   override p.icon.strokeColor = #000
   override p.icon.strokeWidth = .65

   scalar r = ? -- circumradius
   ensure norm( p.position - qi.position ) == r
   ensure norm( p.position - qj.position ) == r
   ensure norm( p.position - qk.position ) == r
   ensure norm( p.position - ql.position ) == r
}

forall Tetrahedron t; Point pi, pj, pk, pl
where t := Tetrahedron( pi, pj, pk, pl ) {

   vec3 Xi = pi.position
   vec3 Xj = pj.position
   vec3 Xk = pk.position
   vec3 Xl = pl.position
   
   vec3 xi = pi.projection
   vec3 xj = pj.projection
   vec3 xk = pk.projection
   vec3 xl = pl.projection

   shape t.f1 = Polygon {
      points: [ xi, xj, xk ]
      fillColor: colors.lightBlue
      strokeColor: colors.black
      strokeWidth: global.lineWidth
      opacity: .1 + max( 0, -cross2D(xj-xi,xk-xi) )
   }
   shape t.f2 = Polygon {
      points: [ xj, xi, xl ]
      fillColor: colors.lightBlue
      strokeColor: colors.black
      strokeWidth: global.lineWidth
      opacity: .1 + max( 0, -cross2D(xi-xj,xl-xj) )
   }
   shape t.f3 = Polygon {
      points: [ xj, xl, xk ]
      fillColor: colors.lightBlue
      strokeColor: colors.black
      strokeWidth: global.lineWidth
      opacity: .1 + max( 0, -cross2D(xl-xj,xk-xj) )
   }
   shape t.f4 = Polygon {
      points: [ xi, xk, xl ]
      fillColor: colors.lightBlue
      strokeColor: colors.black
      strokeWidth: global.lineWidth
      opacity: .1 + max( 0, -cross2D(xk-xi,xl-xi) )
   }

   -- scalar a = 1000
   -- scalar targetAngle = MathPI()/3
   -- encourage a * angleBetween( Xj-Xi, Xk-Xi ) == a * targetAngle
   -- encourage a * angleBetween( Xk-Xj, Xi-Xj ) == a * targetAngle
   -- encourage a * angleBetween( Xi-Xk, Xj-Xk ) == a * targetAngle

   -- encourage a * angleBetween( Xi-Xj, Xl-Xj ) == a * targetAngle
   -- encourage a * angleBetween( Xj-Xl, Xi-Xl ) == a * targetAngle
   -- encourage a * angleBetween( Xl-Xi, Xj-Xi ) == a * targetAngle

   -- encourage a * angleBetween( Xl-Xj, Xk-Xj ) == a * targetAngle
   -- encourage a * angleBetween( Xk-Xl, Xj-Xl ) == a * targetAngle
   -- encourage a * angleBetween( Xj-Xk, Xl-Xk ) == a * targetAngle

   -- encourage a * angleBetween( Xk-Xi, Xl-Xi ) == a * targetAngle
   -- encourage a * angleBetween( Xl-Xk, Xi-Xk ) == a * targetAngle
   -- encourage a * angleBetween( Xi-Xl, Xk-Xl ) == a * targetAngle

   -- ensure determinant( [ Xj-Xi, Xk-Xi, Xl-Xi ] ) > 0
}

forall Point p; Tetrahedron t {
   layer p.icon above t.f1
   layer p.icon above t.f2
   layer p.icon above t.f3
   layer p.icon above t.f4
}

-- forall Point `p1` {
--    override `p1`.position = (0,0,0)
-- }
-- forall Point `p2` {
--    override `p2`.position = (1,1,0)
-- }
-- forall Point `p3` {
--    override `p3`.position = (0,1,1)
-- }
-- forall Point `p4` {
--    override `p4`.position = (1,0,1)
-- }
-- forall Point `p5` {
--    override `p5`.position = (1,1,1)
-- }

