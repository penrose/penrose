canvas {
   width = 1920
   height = 1080

   shape background = Rectangle {
      center: (0,0)
      width: canvas.width
      height: canvas.height
      fillColor: none()
      strokeColor: #000
      strokeWidth: 4
      ensureOnCanvas: false
   }
}

camera {
   -- define the camera viewpoint
   vec3 eye = 4.5*(1,1,1)
   vec3 center = (0,0,0)
   vec3 up = (0,1,0)
   mat4x4 model = lookAt( eye, center, up )

   -- define the camera projection
   scalar fovy = 40 -- degrees
   scalar aspect = canvas.width / canvas.height
   scalar near = 0.1
   scalar far = 100.0
   mat4x4 proj = perspective( fovy, aspect, near, far )

   -- define the canvas / "viewport"
   list view = [ -canvas.width/2, -canvas.height/2, canvas.width, canvas.height ]
}

forall Point p {
   -- pick some random 3D location for each point
   -- (which gets overridden later if this point is used in a shape)
   vec3 p.X = ( random(-1,1), random(-1,1), random(-1,1) )

   -- transform and project the point to (x,y,depth)
   vec3 q = project( p.X, camera.model', camera.proj, camera.view )
   vec2 p.x = ( q[0], q[1] ) -- keep just (x,y)

   -- use the projected point to draw a dot; later these same
   -- coordinates will be used to draw vertices of the tetrahedron
   shape p.icon = Circle {
      center: p.x
      r: 10
      fillColor: #000
      ensureOnCanvas: true
   }
}

forall Tetrahedron t {
   -- give the tetrahedron a random rotation
   scalar angle = ?
   vec3 axis = sphereRandom()
   vec3 t.center = (?,?,?)
   t.model = rotate3d( angle, axis )

   -- keep the tet somewhat near the origin
   ensure 100*norm( t.center ) < 400
}

forall Tetrahedron t; Point p1, p2, p3, p4
where t := Tetrahedron(p1,p2,p3,p4) {

   -- replace the original points with vertices of an equilateral tet
   vec2 c = (1,1,1)/2
   override p1.X = t.model * ( (1,1,0) - c ) + t.center
   override p2.X = t.model * ( (0,1,1) - c ) + t.center
   override p3.X = t.model * ( (1,0,1) - c ) + t.center
   override p4.X = t.model * ( (0,0,0) - c ) + t.center

   -- draw the four faces, using opacity to perform backface culling
   shape t.t123 = Polygon {
      points: [ p1.x, p2.x, p3.x ]
      fillColor: #aa0000dd
      strokeColor: #000
      strokeWidth: 3
      ensureOnCanvas: false
      opacity: max( 0, -cross2D( p2.x-p1.x, p3.x-p1.x ) )
   }
   shape t.t134 = Polygon {
      points: [ p1.x, p3.x, p4.x ]
      fillColor: #00aa00dd
      strokeColor: #000
      strokeWidth: 3
      ensureOnCanvas: false
      opacity: max( 0, cross2D( p3.x-p4.x, p1.x-p4.x ) )
   }
   shape t.t124 = Polygon {
      points: [ p1.x, p2.x, p4.x ]
      fillColor: #0000aadd
      strokeColor: #000
      strokeWidth: 3
      ensureOnCanvas: false
      opacity: max( 0, cross2D( p1.x-p4.x, p2.x-p4.x ) )
   }
   shape t.t234 = Polygon {
      points: [ p2.x, p3.x, p4.x ]
      fillColor: #aacc00dd
      strokeColor: #000
      strokeWidth: 3
      opacity: max( 0, cross2D( p2.x-p4.x, p3.x-p4.x ) )
   }
}

-- label points if they have labels
forall Point p
where p has label {
   p.labelText = Equation {
      center: (?,?)
      string: p.label
      fillColor: #000
      fontSize: "48px"
      ensureOnCanvas: false
   }

   scalar padding = 5
   encourage near( p.labelText, p.icon )
   ensure disjoint( p.labelText, p.icon, padding )
}

-- make sure tets don't overlap in screen space
forall Tetrahedron t1, t2 {
   scalar padding = 32

   ensure disjoint( t1.t123, t2.t123, padding )
   ensure disjoint( t1.t134, t2.t123, padding )
   ensure disjoint( t1.t124, t2.t123, padding )

   ensure disjoint( t1.t123, t2.t134, padding )
   ensure disjoint( t1.t134, t2.t134, padding )
   ensure disjoint( t1.t124, t2.t134, padding )

   ensure disjoint( t1.t123, t2.t124, padding )
   ensure disjoint( t1.t134, t2.t124, padding )
   ensure disjoint( t1.t124, t2.t124, padding )
}

-- also make sure a tet doesn't overlap its labels
forall Tetrahedron t; Point p1, p2, p3, p4
where t := Tetrahedron(p1,p2,p3,p4); p1 has label {
   ensure disjoint( t.t123, p1.labelText, 10 )
}
forall Tetrahedron t; Point p1, p2, p3, p4
where t := Tetrahedron(p1,p2,p3,p4); p2 has label {
   ensure disjoint( t.t123, p2.labelText, 10 )
}
forall Tetrahedron t; Point p1, p2, p3, p4
where t := Tetrahedron(p1,p2,p3,p4); p3 has label {
   ensure disjoint( t.t123, p3.labelText, 10 )
}
forall Tetrahedron t; Point p1, p2, p3, p4
where t := Tetrahedron(p1,p2,p3,p4); p4 has label {
   ensure disjoint( t.t123, p4.labelText, 10 )
}

