canvas {
    width = 1200
    height = 700
}

layout = [sort, disjoint]

colors {
    darkgray = #333333
    gray = #D3D3D3
    lightgray = #F5F5F5
    green = #B6DDBF
    purple = #D4CEE8
    blue = #d5e3ff
}

global {
    --- parameters that user may want to tweek
    eventHeight = 35
    eventLabelFontSize = "14pt"
    eventFontStyle = "italic"
    periodFontSize = "16pt"
    periodFontStyle = "bold"

    fontFamily = "Garamond"

    marginTop = 25
    marginBottom = 25
    marginLeft = 25
    marginRight = 25

    yearHeight = 40
    quarterHeight = 40

    gridLineWeight = 2
    eventStrokeWeight = 1
    eventCornerRadius = 8
    eventPadding = 10

    --- parameters that are calculated
    topGridY = (canvas.height / 2) - marginTop
    topQuarterY = topGridY - yearHeight
    lineY = topQuarterY - quarterHeight
    bottomGridY = -(canvas.height / 2) + marginBottom
    startX =- (canvas.width / 2) + marginLeft
    endX = (canvas.width / 2) - marginRight
    lineLength = endX - startX
    startLine = (startX, lineY)
    endLine = (endX, lineY)
    shape baseline = Line {
        start : startLine
        end : endLine
        strokeWidth : global.gridLineWeight
        strokeColor: colors.gray
    }

}

forall Year y {
    y.minX = ?
    y.maxX = ?
    y.centerX = average2(y.minX, y.maxX)
    y.centerY = global.topGridY - (global.yearHeight / 2)
    y.icon = Text {
        center : (y.centerX, y.centerY)
        string : y.label
        fillColor : colors.darkgray
        fontSize : global.periodFontSize
        fontStyle : global.periodFontStyle
        fontFamily: global.fontFamily
    }
    y.slotBegin = Line {
        start : (y.minX,global.topQuarterY)
        end : (y.minX,global.topGridY)
        strokeWidth : global.gridLineWeight
        strokeColor: colors.gray
    }
    y.slotEnd = Line {
        start : (y.maxX,global.topQuarterY)
        end : (y.maxX,global.topGridY)
        strokeWidth : global.gridLineWeight
        strokeColor: colors.gray
    }
}

forall Quarter q {
    denominator = (match_total * 2)
    index = (match_id - 1) * 2
    startRatio = index / denominator
    middleRatio = (index + 1) / denominator
    endRatio = (index + 2) / denominator
    ratioX = ((match_id * 2) - 1) / (match_total * 2)
    totalSlotX = global.lineLength
    q.startSlotX = global.startX + startRatio * totalSlotX
    q.middleSlotX = global.startX + middleRatio * totalSlotX
    q.endSlotX = global.startX +endRatio * totalSlotX
    q.x = q.middleSlotX
    q.y = global.lineY + (global.quarterHeight / 2)
    q.icon = Text {
        center : (q.x, q.y)
        string : q.label
        fillColor : colors.darkgray
        fontSize : global.periodFontSize
        fontStyle : global.periodFontStyle
        fontFamily: global.fontFamily
    }
    q.slotBegin = Line {
        start : (q.startSlotX,global.bottomGridY)
        end : (q.startSlotX,global.topQuarterY)
        strokeWidth : global.gridLineWeight
        strokeColor: colors.gray
    }
    q.slotEnd = Line {
        start : (q.endSlotX,global.bottomGridY)
        end : (q.endSlotX,global.topQuarterY)
        strokeWidth : global.gridLineWeight
        strokeColor: colors.gray
    }
    layer q.slotEnd above q.slotBegin
    layer q.slotEnd below global.baseline
    layer q.slotBegin below global.baseline
}

forall Quarter q1; Quarter q2
where Before(q1, q2) {
    layer q2.slotBegin above q1.slotEnd
}

forall Quarter q
where First(q,y)
with Year y {
    y.minX = q.startSlotX
}

forall Quarter q
where Last(q,y)
with Year y {
    y.maxX = q.endSlotX
}


forall Event e
where e := MkEvent(start, end)
with Quarter start; Quarter end;{
    e.centerY = ?
    topBox = e.centerY + global.eventHeight/2
    bottomBox = e.centerY - global.eventHeight/2
    centerX = ((end.endSlotX - start.startSlotX) / 2) + start.startSlotX
    e.icon = Rectangle {
        height : global.eventHeight
        width : end.endSlotX - start.startSlotX
        center: (centerX, e.centerY)
        cornerRadius : global.eventCornerRadius
        strokeWidth : global.eventStrokeWeight
        strokeColor: colors.darkgray
    }

    e.text = Text {
        string : e.label
        fontSize : global.eventLabelFontSize
        fillColor : colors.darkgray
        center : (centerX, e.centerY)
        fontStyle: global.eventFontStyle
        fontFamily: global.fontFamily
    }
    topWithPadding = global.lineY - global.eventPadding
    ensure lessThan(topBox, topWithPadding)
    bottomWithPadding = global.bottomGridY + global.eventPadding
    ensure greaterThan(bottomBox, bottomWithPadding)
    layer e.icon above end.slotEnd
    layer e.text above e.icon
}

forall Event e
where In(e, `access`)
with Category `access` {
   e.icon.fillColor = colors.green
}

forall Event e
where In (e, `milestone`)
with  Category `milestone` {
   e.icon.fillColor = colors.blue
}

forall Event e
where In(e, `outcome`)
with Category `outcome` {
   e.icon.fillColor = colors.purple
}

forall Event e1; Event e2
where In(e1, `outcome`); In(e2, `access`)
with Category `outcome`; Category `access`
{
  ensure e1.centerY > (e2.centerY + global.eventPadding + global.eventHeight) in [sort,disjoint]
}

forall Event e1; Event e2;
where In(e1, `access`); In(e2, `milestone`)
with Category `access`; Category `milestone`
{
  ensure e1.centerY >  (e2.centerY + global.eventPadding + global.eventHeight) in [sort,disjoint]
}

forall Event e1; Event e2;
where In(e1, `outcome`); In(e2, `milestone`)
with Category `outcome`; Category `milestone`
{
  ensure e1.centerY >  (e2.centerY + global.eventPadding + global.eventHeight) in [sort,disjoint]
}

forall Event e1, e2 {
    ensure disjoint(e1.icon, e2.icon, global.eventPadding) in disjoint
}