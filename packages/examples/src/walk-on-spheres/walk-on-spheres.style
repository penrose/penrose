layout = [ walkStage, labelStage ]

-- diagram dimensions (in px)
canvas {
   width = 240
   height = 200
}

-- some colors re-used throughout
Colors {
   color black = rgba(0,0,0,1)
   color white = rgba(1,1,1,1)
   color darkGray = rgba(.5,.5,.5,1)
   color lightGray = rgba(.9,.9,.9,1)
}

-- global shapes and constants
Global {
   -- default appearance for label text
   string labelFont = "Charter"
   string labelSize = "9px"
   color labelColor = Colors.black
   color labelStrokeColor = Colors.white
   scalar labelStrokeWidth = 1.5

   -- line thickness for basic shapes
   scalar sphereStrokeWidth = 1
   scalar domainStrokeWidth = 1.5

   -- style of lines along a walk
   -- (set color to none() to disable)
   color walkColor = rgba( 0, 0, .7, 1 )
   color walkStrokeWidth = 1.5

   -- draw the domain as a polygon with some random variation, by
   -- perturbing the vertices of a hexagon by some bounded amount
   -- Note: if the domain shape is changed to something else (like
   -- an ellipse or a rectangle), things _should_ still work as
   -- expected, since later methods just make a call to `signedDistance`
   -- to determine ball radii.  However, signed distance may not yet
   -- be supported for all shapes (like arbitrary Bézier curves).
   scalar maxPerturbation = 15
   scalar w = .8*canvas.width/2
   scalar h = .8*canvas.height/2
   vec2 p0 = ( w, -h) + maxPerturbation*diskRandom()
   vec2 p1 = ( 0, -h) + maxPerturbation*diskRandom()
   vec2 p2 = (-w, -h) + maxPerturbation*diskRandom()
   vec2 p3 = (-w,  h) + maxPerturbation*diskRandom()
   vec2 p4 = ( 0,  h) + maxPerturbation*diskRandom()
   vec2 p5 = ( w,  h) + maxPerturbation*diskRandom()
   shape domain = Polygon {
      points: ( p0, p1, p2, p3, p4, p5)
      fillColor: Colors.lightGray
      strokeColor: Colors.darkGray
      strokeWidth: Global.domainStrokeWidth
      ensureOnCanvas: false
   }
}

-- label the domain if it was assigned a label in the Substance program
forall Domain U
where U has label {

   scalar x = ? in labelStage
   scalar y = ? in labelStage
   shape U.labelText = Text {
      string: U.label
      center: (x,y)
      fontSize: Global.labelSize
      fontFamily: Global.labelFont
      fillColor: Colors.darkGray
      ensureOnCanvas: false
   }

   ensure lessThan( signedDistance( Global.domain, U.labelText.center ), -9. ) in labelStage

   layer U.labelText above Global.domain -- make sure the label doesn't get covered by the domain shape
}

-- draw each point as a small dot
forall Point p {
   scalar x = ? in walkStage
   scalar y = ? in walkStage
   vec2 p.location = (x,y)

   -- The `dot` shape represents the sample point associated
   -- with the ball.  Ordinarily this point will be at the
   -- center of the ball, but in general it could be at a
   -- different location (e.g., for an off-center walk).
   shape p.dot = Circle {
      center: p.location
      r: 2.5
      fillColor: Colors.black
      ensureOnCanvas: false
   }
}

-- TODO We will be able to make more of the Style program generic across
-- TODO different types of subdomains (balls and stars) by giving a generic
-- TODO name like "interior" to each subdomain.  Rules that need to sample
-- TODO points in these subdomains can then use "ensure contains" rather than
-- TODO explicit calculations based on circular disks.

-- draw each Ball as the largest ball tangent to the domain boundary
forall Ball B {

   -- Make sure the ball is inside the problem domain by
   -- setting its radius to (minus) the signed distance to
   -- the domain boundary.  This value is negated since, by
   -- convention, points inside the domain have negative
   -- signed distance.
   scalar x = ? in walkStage
   scalar y = ? in walkStage
   vec2 B.center = (x,y)
   scalar B.radius = -signedDistance( Global.domain, B.center ) - Global.sphereStrokeWidth/2 - Global.domainStrokeWidth/2.

   -- The `ball` shape is a flat-shaded semi-transparent
   -- disk that determines the color of the ball.
   -- The ball radius equals the distance from the
   -- ball center to the closest point on the domain boundary
   -- (just as in the WoS algorithm!).  We also subtract half
   -- the stroke widths so that visually the ball makes perfect
   -- tangential contact with the domain boundary.
   -- Note that we don't need to
   -- explicitly enforce that the ball remains on the canvas,
   -- since the domain shape already has an onCanvas constraint,
   -- and the balls are always contained in the domain shape, by
   -- construction.
   shape B.ball = Circle {
      center: B.center
      r: B.radius
      fillColor: rgba( .2, .8, .2, .15 )
      strokeColor: none()
      ensureOnCanvas: false
   }

   -- The `sphere` shape represents the boundary of the ball,
   -- and is drawn as an empty circle with a thick line.
   shape B.sphere = Circle {
      center: B.center
      r: B.radius
      fillColor: none()
      strokeColor: rgba( .4, .5, .4, 1 )
      strokeWidth: Global.sphereStrokeWidth
      ensureOnCanvas: false
   }

   -- To give the balls a three-dimensional appearance, blend
   -- a shading image behind the flat colored disk.
   shape B.shading = Image {
      center: B.center
      width: B.radius * 2.0
      height: B.radius * 2.0
      href: "walk-on-spheres-ball.svg"
      ensureOnCanvas: false
   }

   -- Make sure all components of the ball get drawn in the
   -- proper order, and are not covered up by the domain shape.
   layer B.shading above Global.domain
   layer B.ball above B.shading
   layer B.sphere above B.ball

   -- This constant determines how much balls shrink from one
   -- step of the walk to the next.  We define it as a named
   -- constant so that specialized types of balls (say, those
   -- coming from a nested walk) can use a different factor.
   scalar B.shrinkFactor = .55
}

-- Make sure the domain's label isn't covered up by a ball.
forall Ball B; Domain U
where U has label {
   scalar padding = 10.
   ensure disjoint( U.labelText, B.sphere, padding ) in labelStage
}

-- If a ball is constructed around a point, center it around that point
forall Point p; Ball B
where B := ballAround( p ) {
   override B.center = p.location
   layer p.dot above B.ball
}

-- For a step of an off-centered walk, we want to clearly
-- indicate that the sample point may not be at the ball center.
forall Ball B; Point p
where B := ballAround(p); isOffCenter(B) {

   -- We can no longer just copy the ball center from the point center,
   -- but will instead let the layout engine determine its location.
   scalar x = ? in walkStage
   scalar y = ? in walkStage
   override B.center = (x,y)

   -- Still keep the center within the middle 25–75% of the ball, since
   -- the dot may be hard to see if it gets too close to the boundary
   -- (especially for very small balls).
   scalar r = B.radius * random(.25,.75)
   ensure norm(B.center - p.location) == r in walkStage
}

-- If a point has a label, draw a label string near the dot.
forall Point p
where p has label {
   shape p.labelText = Text {
      string: p.label
      fontSize: Global.labelSize
      fontFamily: Global.labelFont
      fontStyle: "italic"
      fillColor: Global.labelColor
      strokeColor: Global.labelStrokeColor
      strokeWidth: Global.labelStrokeWidth
      strokeLinejoin: "round"
      paintOrder: "stroke"
      ensureOnCanvas: false
   }

   -- We want the label to be near the dot, but don't want it
   -- to overlap the dot (which makes it hard to read).
   scalar theta = ? in labelStage
   p.labelText.center = p.dot.center + 8.*( cos(theta), sin(theta) )

   -- If we fail to avoid overlap, we should
   -- at least draw the label on top of the dot
   layer p.labelText above p.dot
}

-- Make sure a point's label doesn't get covered by a ball
-- containing it, by layering it above the topmost ball shape.
forall Point p; Ball B
where B := ballAround( p ); p has label {
   layer p.labelText above B.sphere
}

-- Draw nested steps of a walk in a different style.
forall Ball B; Point p
where isNested( B ); B := ballAround( p ) {
   -- Change to a color palette that is more white & opaque.
   override B.ball.fillColor = none()
   override B.ball.strokeColor = none()
   override B.sphere.strokeColor = none()
   override p.dot.fillColor = Colors.white
   override B.shading = Circle{
      center: B.center
      r: B.radius
      fillColor: rgba(1,1,1,.2)
      strokeColor: rgba(1,1,1,.5)
      strokeWidth: 1
   }

   -- Since nested walks are usually secondary in the overall
   -- diagram, draw them smaller by making them shrink faster.
   override B.shrinkFactor = .7
}

-- TODO for completeness, we should also define a rule for nested Stars
-- forall Ball B; Point p
-- where isNested( B ); B := starAround( p ) {
   -- TODO
-- }

-- If a point p is sampled from the boundary of a ball B,
-- make sure it sits on the corresponding sphere ∂B.
forall Ball B; Point p
where p := sampleBoundary( B ) {
   ensure equal( norm(p.location - B.center), B.radius ) in walkStage

   -- Make sure the dot is not covered by the sphere.
   layer p.dot above B.sphere
}

-- If a point p is sampled from the interior of a ball B,
-- make sure it sits somewhere between 20% and 80% away
-- from the center, so that it's clearly visible and doesn't
-- run into the center point or the boundary.
forall Ball B; Point p
where p := sampleInterior( B ) {
   scalar r = B.radius * random(.2,.8)
   ensure norm( p.location - B.center ) == r in walkStage

   -- Make sure the dot is not covered by the ball.
   layer p.dot above B.ball
}

forall Point p1; Point p2; Ball B0; Ball B1; Ball B2
where isNested(B2); p1 := sampleBoundary(B0); B1 := ballAround(p1); p2 := sampleInterior(B1); B2 := ballAround(p2) {
   override B2.radius = .1 * B1.radius
}


-- Adjust the drawing for consecutive steps x0, x1 along a walk on spheres,
-- where B0, B1 are the associated spheres.
forall Ball B0; Ball B1; Point x0; Point x1
where x1 := sampleBoundary( B0 ); B0 := ballAround( x0 ); B1 := ballAround( x1 ) {
   -- draw later steps of a walk as smaller balls (which is often, but
   -- not always, the behavior of the WoS algorithm)
   ensure equal( B1.radius, B1.shrinkFactor * B0.radius ) in walkStage

   -- It's typically easier to see labels, etc., if later, smaller
   -- balls are drawn on top of earlier, bigger ones.
   layer B1.shading above B0.sphere
}

-- Draw a line between the consecutive points on a walk on spheres
forall Point x0; Point x1; Ball B0; Ball B1
where x1 := sampleBoundary( B0 ); B0 := ballAround( x0 ); B1 := ballAround( x1 ) {

   shape x0.walkLine = Line {
      start: x0.location
      end: x1.location
      strokeColor: Global.walkColor
      strokeWidth: Global.walkStrokeWidth
      ensureOnCanvas: false
   }
   layer x0.walkLine above Global.domain

   -- Use layering to help clarify the direction of the walk.
   layer x0.walkLine above B0.shading
   layer x0.walkLine below B1.shading
}

-- If points have labels, make sure they don't overlap the walk line
forall Point x0; Point x1; Ball B0; Ball B1
where x0 has label; x1 := sampleBoundary( B0 ); B0 := ballAround( x0 ); B1 := ballAround( x1 ) {
   ensure disjoint ( x0.walkLine, x0.labelText, 3. ) in labelStage
}
forall Point x0; Point x1; Ball B0; Ball B1
where x1 has label; x1 := sampleBoundary( B0 ); B0 := ballAround( x0 ); B1 := ballAround( x1 ) {
   ensure disjoint ( x0.walkLine, x1.labelText, 3. ) in labelStage
}

forall Point x0; Point x1; Ball B0; Ball B1
where isNested(B0); isNested(B1); x1 := sampleBoundary( B0 ); B0 := ballAround( x0 ); B1 := ballAround( x1 ) {
   override x0.walkLine.strokeColor = Colors.white
}

-- -- Draw a line between the consecutive points on a walk on stars
-- forall Point x0; Point x1; Star St0; Star St1
-- where x1 := sampleBoundary( St0 ); St0 := starAround( x0 ); St1 := starAround( x1 ) {
-- 
--    -- TODO we *might* be able to eliminate redundancy with the previous rule by
--    -- TODO changing ballAround()/starAround() to subdomainAround().  This all depends
--    -- TODO on whether the Style compiler will separately match the two rules
--    -- TODO    Ball B  where B  := subdomainAround(p)
--    -- TODO    Star St where St := subdomainAround(p)
--    -- TODO (and I don't immediately see why it shouldn't...).  In other words, unlike
--    -- TODO C++, we can effectively "overload" rules based on "return type."  This change
--    -- TODO would also just simplify and clean up our Domain schema, since we no longer
--    -- TODO have to carefully match the subdomain type with the method used to construct
--    -- TODO the subdomain.
-- 
--    shape walkLine = Line {
--       start: x0.location
--       end: x1.location
--       strokeColor: Global.walkColor
--       strokeWidth: Global.walkStrokeWidth
--    }
--    layer walkLine above Global.domain
-- 
--    -- Use layering to help clarify the direction of the walk.
--    layer walkLine above St0.shading
--    layer walkLine below St1.shading
-- }

-- Draw sample points that are used to estimate the source term
-- as just dots contained in the ball of interest.  These sample
-- points are different from steps of a walk, since we never
-- need to consider a ball around these points (and hence do not
-- want to draw one).
forall Point p; Ball B
where p := sampleInterior( B ); isSourceSample( p ) {
   scalar x = ? in walkStage
   scalar y = ? in walkStage
   -- Draw source samples in a different style
   override p.location = (x,y)
   override p.dot.r = 2
   override p.dot.fillColor = Colors.white
   override p.dot.strokeColor = Colors.black
   override p.dot.strokeWidth = 1
}

-- Put all labels above all balls
forall Point p; Ball B
where p has label {
   layer p.labelText above B.sphere
}

-- Put all labels above all dots and
-- encourage labels not to overlap
forall Point p; Point q
where p has label; q has label {
   layer p.labelText above q.dot
   layer q.labelText above p.dot

   vec2 px = p.location
   vec2 qx = q.location
   vec2 pc = p.labelText.center
   vec2 qc = q.labelText.center
   encourage 1000./norm(pc - qc) == 0. in labelStage
}

forall Point p; Point q
where p has label {
   layer p.labelText above q.dot
}

forall Point p; Point q
where p has label; isSourceSample(q) {
   vec2 pc = p.labelText.center
   vec2 qx = q.location
   encourage 1000./norm(pc - qx) == 0. in labelStage
}

