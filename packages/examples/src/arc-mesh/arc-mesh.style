canvas {
  width = 240
  height = 200
}

colors {
   color debug = #ff6600

   -- main color for points and lines/curves
   color point = #000
   color line = #000

   -- fill color for solid regions
   color solidRegion = #1b1f8a33

   -- fill and stroke color for ancillary points
   color secondaryPointFill = #fff
   color secondaryPointStroke = #000

   -- stroke color for ancillary lines
   color secondaryLine = #1b1f8a

   -- stroke color for lines/curves used to indicate
   -- geometric constructions
   color constructionLine = #0003
}

global {

  -- default size for vertices, points, etc.
  scalar dotSize = 2.0

  -- default width for lines/curves
  scalar lineWidth = 1

  -- width for secondary lines/curves
  scalar secondaryLineWidth = 0.8
  
  -- size of angle markers
  scalar straightAngleRadius = 15
  scalar circularAngleRadius = 20
  scalar bendAngleRadius = 25

  -- labels
  string labelFont = "Linux Libertine O"
  string labelStyle = "italic"
  string labelSize = "9px"
  scalar labelSizeNum = 9
}

forall Vertex v {
  vec2 v.p = (?,?)
  shape v.icon = Circle {
    center: v.p
    r: global.dotSize
    fillColor: colors.point
  }
}

forall Vertex v; Number x,y
where SetPosition(v,x,y) {
   override v.p = (x,y)
}

forall Edge e; Vertex u, v
where e := Edge(u,v) {

  vec2 e.start = u.p
  vec2 e.end = v.p

  shape e.segment = Line {
    start: e.start
    end: e.end
    strokeDasharray: "4 6"
    strokeColor: colors.constructionLine
  }

  scalar e.alpha = random( -1, 1 ) * MathPI()/4 -- bend angle
  vec2 m = ( e.start + e.end )/2 -- midpoint
  scalar h = .5 / tan(e.alpha) -- unnormalized distance to circle center
  vec2 n = rot90( e.start - e.end ) -- unnormalized normal
  vec2 e.c = m + n*h -- circle center

  vec2 w0 = e.start - e.c -- vector to start point
  vec2 w1 = e.end - e.c -- vector to end point
  scalar theta0 = angleFrom( (1,0), w0 ) -- angle to start point
  scalar theta1 = theta0 + angleFrom( w0, w1 ) -- angle to end point
  scalar e.r = norm(w0) -- circle radius

  e.bentPath = circularArc( "open", e.c, e.r, theta0, theta1 )

  shape e.arc = Path {
    d: e.bentPath
    strokeColor: colors.line
    strokeWidth: global.lineWidth
  }
}

forall Edge e; Number alpha
where SetBendAngle( e, alpha ) {
   override e.alpha = -alpha
}

forall Triangle t; Edge ij, jk, ki
where t := Triangle(ij,jk,ki) {
   t.pi = ij.start
   t.pj = jk.start
   t.pk = ki.start

   shape t.straightRegion = Polygon {
     points: [ t.pi, t.pj, t.pk ]
     fillColor: colors.solidRegion
     strokeColor: none()
   }

   shape t.circularRegion = Path {
     d: joinPaths([ij.bentPath, jk.bentPath, ki.bentPath])
     fillColor: colors.solidRegion
     strokeColor: none()
   }
}

-- Draw each angle marker as a circular disk, which gets
-- clipped against some other geometry to make a wedge.
forall Angle A {
   vec2 A.c = (0,0)
   scalar A.r = 20
   scalar A.theta0 = 0
   scalar A.theta1 = MathPI()/3

   shape A.disk = Circle {
      center: A.c
      r: A.r
      fillColor: colors.solidRegion
      strokeColor: colors.secondaryLine
      strokeWidth: global.secondaryLineWidth
   }
   shape A.mask = Circle {
      center: A.disk.center
      r: A.disk.r
   }
   shape A.icon = Group {
      shapes: [ A.disk ]
      clipPath: clip( A.mask )
   }
}

forall Angle A; Triangle ijk
where A := FirstStraightCorner( ijk ) {
   override A.c = ijk.pi
   override A.r = global.straightAngleRadius
   override A.mask = Polygon {
      points: ijk.straightRegion.points
      fillColor: A.disk.fillColor
   }
}
forall Angle A; Triangle ijk
where A := SecondStraightCorner( ijk ) {
   override A.c = ijk.pj
   override A.r = global.straightAngleRadius
   override A.mask = Polygon {
      points: ijk.straightRegion.points
      fillColor: A.disk.fillColor
   }
}
forall Angle A; Triangle ijk
where A := ThirdStraightCorner( ijk ) {
   override A.c = ijk.pk
   override A.r = global.straightAngleRadius
   override A.mask = Polygon {
      points: ijk.straightRegion.points
      fillColor: A.disk.fillColor
   }
}

forall Angle A; Triangle ijk
where A := FirstCircularCorner( ijk ) {
   override A.c = ijk.pi
   override A.r = global.circularAngleRadius
   override A.mask = Path {
      d: ijk.circularRegion.d
      fillColor: A.disk.fillColor
   }
}
forall Angle A; Triangle ijk
where A := SecondCircularCorner( ijk ) {
   override A.c = ijk.pj
   override A.r = global.circularAngleRadius
   override A.mask = Path {
      d: ijk.circularRegion.d
      fillColor: A.disk.fillColor
   }
}
forall Angle A; Triangle ijk
where A := ThirdCircularCorner( ijk ) {
   override A.c = ijk.pk
   override A.r = global.circularAngleRadius
   override A.mask = Path {
      d: ijk.circularRegion.d
      fillColor: A.disk.fillColor
   }
}

forall Angle A; Edge ij
where A := StartBendAngle( ij ) {
   override A.r = global.bendAngleRadius
   override A.c = ij.start
   override A.mask = Path {
      d: joinPaths( [ij.bentPath] )
      fillColor: A.disk.fillColor
      strokeColor: colors.debug
      strokeWidth: global.lineWidth
   }
}
forall Angle A; Edge ij
where A := EndBendAngle( ij ) {
   override A.r = global.bendAngleRadius
   override A.c = ij.end
   override A.mask = Path {
      d: joinPaths( [ij.bentPath] )
      fillColor: A.disk.fillColor
   }
}

forall Circle C {
   vec2 C.c = (?,?)
   scalar C.r = abs(?)
   C.icon = Circle {
      center: C.c
      r: C.r
      fillColor: none()
      strokeColor: colors.constructionLine
      strokeWidth: global.lineWidth
   }
}

-- draw the circle associated with the arc through a given edge
forall Circle C; Edge ij
where C := CircleThrough( ij ) {

   -- copy the center and radius of the
   -- edge's circular arc, so that it
   -- can be more easily referenced by
   -- rules that reference this circle
   override C.c = ij.c
   override C.r = ij.r
}

forall Point P {
   vec2 P.p = (?,?)

   shape P.icon = Circle {
      center: P.p
      r: global.dotSize
      fillColor: colors.secondaryPointFill
      strokeColor: colors.secondaryPointStroke
      strokeWidth: global.secondaryLineWidth
   }
}

forall Point P; Circle C
where P := CenterOf(C) {
   override P.p = C.c
}

forall Segment S {
   vec2 S.start = (?,?)
   vec2 S.end = (?,?)

   S.icon = Line {
      start: S.start
      end: S.end
      strokeWidth: global.lineWidth
      strokeColor: colors.constructionLine
   }
}

forall Segment S; Circle C
where S := RadiusOf(C) {
   override S.start = C.c
   override S.end = C.c + circleRandom()*C.r
}

forall Segment S; Edge e
where S := LengthMarker(e) {
   scalar offset = 8
   scalar markerSize = 3

   vec2 p0 = e.start
   vec2 p1 = e.end
   vec2 t = unit(p1-p0)
   vec2 n = -rot90(t)
   vec2 a = p0 + offset*n
   vec2 b = p1 + offset*n

   override S.start = a
   override S.end = b

   color markerColor = #ddd
   override S.icon.strokeColor = markerColor

   shape markerA = Line {
      start: a - markerSize*n
      end: a + markerSize*n
      strokeColor: markerColor
      strokeWidth: S.icon.strokeWidth
   }
   shape markerB = Line {
      start: b - markerSize*n
      end: b + markerSize*n
      strokeColor: markerColor
      strokeWidth: S.icon.strokeWidth
   }
   shape G = Group {
      shapes: [ S.icon, markerA, markerB ]
   }
}

forall Triangle t
where HideStraightRegion(t) {
   override t.straightRegion.fillColor = none()
}

forall Triangle t
where HideCircularRegion(t) {
   override t.circularRegion.fillColor = none()
}

-- Layering

forall Circle C; Point P; Segment S
where P := CenterOf(C); S := RadiusOf(C) {
   layer P.icon above S.icon
   layer S.icon above C.icon
}

forall Point P; Triangle T {
   layer P.icon above T.straightRegion
   layer P.icon above T.circularRegion
}

