canvas {
  width = 240
  height = 200
}

global {
  scalar pointSize = 2.0
  
  -- size of angle markers
  scalar straightAngleRadius = 15
  scalar circularAngleRadius = 20
  scalar bendAngleRadius = 25
}

forall Vertex v {
  vec2 v.p = (?,?)
  shape v.icon = Circle {
    center: v.p
    r: global.pointSize
    fillColor: #000
  }
}

forall Vertex v; Number x,y
where SetPosition(v,x,y) {
   override v.p = (x,y)
}

forall Edge e; Vertex u, v
where e := Edge(u,v) {

  vec2 e.start = u.p
  vec2 e.end = v.p

  shape e.segment = Line {
    start: e.start
    end: e.end
    strokeDasharray: "4 6"
    strokeColor: #1b1f8a33
  }

  scalar e.alpha = random( -1, 1 ) * MathPI()/4 -- bend angle
  vec2 m = ( e.start + e.end )/2 -- midpoint
  scalar h = .5 / tan(e.alpha) -- unnormalized distance to circle center
  vec2 n = rot90( e.start - e.end ) -- unnormalized normal
  vec2 e.c = m + n*h -- circle center

  vec2 w0 = e.start - e.c -- vector to start point
  vec2 w1 = e.end - e.c -- vector to end point
  scalar theta0 = angleFrom( (1,0), w0 ) -- angle to start point
  scalar theta1 = theta0 + angleFrom( w0, w1 ) -- angle to end point
  scalar e.r = norm(w0) -- circle radius

  e.bentPath = circularArc( "open", e.c, e.r, theta0, theta1 )

  shape e.arc = Path {
    d: e.bentPath
    strokeColor: #000
    strokeWidth: 1
  }
}

forall Edge e; Number alpha
where SetBendAngle( e, alpha ) {
   override e.alpha = -alpha
}

forall Triangle t; Edge ij, jk, ki
where t := Triangle(ij,jk,ki) {
   t.pi = ij.start
   t.pj = jk.start
   t.pk = ki.start

   shape t.straightRegion = Polygon {
     points: [ t.pi, t.pj, t.pk ]
     fillColor: #1b1f8a33
     strokeColor: none()
   }

   shape t.circularRegion = Path {
     d: joinPaths([ij.bentPath, jk.bentPath, ki.bentPath])
     fillColor: #1b1f8a33
     strokeColor: none()
   }
}

-- Draw each angle marker as a circular disk, which gets
-- clipped against some other geometry to make a wedge.
forall Angle A {
   vec2 A.c = (0,0)
   scalar A.r = 20
   scalar A.theta0 = 0
   scalar A.theta1 = MathPI()/3

   shape A.disk = Circle {
      center: A.c
      r: A.r
      fillColor: #1b1f8a33
      strokeColor: #1b1f8a
      strokeWidth: 1
   }
   shape A.mask = Circle {
      center: A.disk.center
      r: A.disk.r
   }
   shape A.icon = Group {
      shapes: [ A.disk ]
      clipPath: clip( A.mask )
   }
}

forall Angle A; Triangle ijk
where A := FirstStraightCorner( ijk ) {
   override A.c = ijk.pi
   override A.r = global.straightAngleRadius
   override A.mask = Polygon {
      points: ijk.straightRegion.points
      fillColor: A.disk.fillColor
   }
}
forall Angle A; Triangle ijk
where A := SecondStraightCorner( ijk ) {
   override A.c = ijk.pj
   override A.r = global.straightAngleRadius
   override A.mask = Polygon {
      points: ijk.straightRegion.points
      fillColor: A.disk.fillColor
   }
}
forall Angle A; Triangle ijk
where A := ThirdStraightCorner( ijk ) {
   override A.c = ijk.pk
   override A.r = global.straightAngleRadius
   override A.mask = Polygon {
      points: ijk.straightRegion.points
      fillColor: A.disk.fillColor
   }
}

forall Angle A; Triangle ijk
where A := FirstCircularCorner( ijk ) {
   override A.c = ijk.pi
   override A.r = global.circularAngleRadius
   override A.mask = Path {
      d: ijk.circularRegion.d
      fillColor: A.disk.fillColor
   }
}
forall Angle A; Triangle ijk
where A := SecondCircularCorner( ijk ) {
   override A.c = ijk.pj
   override A.r = global.circularAngleRadius
   override A.mask = Path {
      d: ijk.circularRegion.d
      fillColor: A.disk.fillColor
   }
}
forall Angle A; Triangle ijk
where A := ThirdCircularCorner( ijk ) {
   override A.c = ijk.pk
   override A.r = global.circularAngleRadius
   override A.mask = Path {
      d: ijk.circularRegion.d
      fillColor: A.disk.fillColor
   }
}

forall Angle A; Edge ij
where A := StartBendAngle( ij ) {
   override A.r = global.bendAngleRadius
   override A.c = ij.start
   override A.mask = Path {
      d: joinPaths( [ij.bentPath] )
      fillColor: A.disk.fillColor
      strokeColor: #000
      strokeWidth: 1
   }
}
forall Angle A; Edge ij
where A := EndBendAngle( ij ) {
   override A.r = global.bendAngleRadius
   override A.c = ij.end
   override A.mask = Path {
      d: joinPaths( [ij.bentPath] )
      fillColor: A.disk.fillColor
   }
}

forall Circle C {
   vec2 C.c = (?,?)
   scalar C.r = abs(?)
   C.icon = Circle {
      center: C.c
      r: C.r
      fillColor: none()
      strokeColor: #0004
      strokeWidth: 1
   }
}

-- draw the circle associated with the arc through a given edge
forall Circle C; Edge ij
where C := CircleThrough( ij ) {

   -- copy the center and radius of the
   -- edge's circular arc, so that it
   -- can be more easily referenced by
   -- rules that reference this circle
   override C.c = ij.c
   override C.r = ij.r
}

forall Point P {
   vec2 P.p = (?,?)

   shape P.icon = Circle {
      center: P.p
      r: global.pointSize
      fillColor: #fff
      strokeColor: #000
      strokeWidth: .65
   }
}

forall Point P; Circle C
where P := CenterOf(C) {
   override P.p = C.c
}

forall Segment S {
   vec2 S.start = (?,?)
   vec2 S.end = (?,?)

   S.icon = Line {
      start: S.start
      end: S.end
      strokeWidth: 1
      strokeColor: #0003
   }
}

forall Segment S; Circle C
where S := RadiusOf(C) {
   override S.start = C.c
   override S.end = C.c + circleRandom()*C.r
}

forall Triangle t
where HideStraightRegion(t) {
   override t.straightRegion.fillColor = none()
}

forall Triangle t
where HideCircularRegion(t) {
   override t.circularRegion.fillColor = none()
}

-- Layering

forall Circle C; Point P; Segment S
where P := CenterOf(C); S := RadiusOf(C) {
   layer P.icon above S.icon
   layer S.icon above C.icon
}

forall Point P; Triangle T {
   layer P.icon above T.straightRegion
   layer P.icon above T.circularRegion
}

