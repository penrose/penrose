canvas {
  width = 800
  height = 700
}

layout = [dots, loops, text]

color {
  black = #000000
  white = #ffffff
}

num {
  radius = 5
  labelDist = 5
  edgeDist = 100
  offset = 10
  loopRadius = 15
  pointerX = 6
  pointerY = 4
}

forall Vertex v {
  v.dot = Circle {
    center: (? in dots, ? in dots)
    r: num.radius
    fillColor : color.black
  }

  v.text = Text {
    string: v.label
    fillColor: color.black
    fontFamily: "serif"
    fontSize: "18px"
    strokeColor: color.white
    strokeWidth: 4
    paintOrder: "stroke"
  }

  v.text above v.dot

  ensure disjoint(v.dot, v.text, num.labelDist) in text
  encourage near(v.dot, v.text) in text
}

forall Vertex u; Vertex v {
  encourage notTooClose(u.dot, v.dot) in dots
}

forall Vertex u; Vertex v; Link e where e := Edge(u, v) {
  a = u.dot.center
  b = v.dot.center
  t = normalize(b - a) -- tangent
  n = rot90(t) -- normal
  m = (a + b) / 2 -- midpoint

  e.tangent = t
  e.offset = ? in dots
  e.arrow = Path {
    d: quadraticCurveFromPoints("open", [a, m + e.offset * n, b])
    strokeColor: color.black
  }

  e.arrow below u.dot
  e.arrow below v.dot

  encourage vdist(u.dot.center, v.dot.center) < num.edgeDist in dots
  encourage minimal(sqr(e.offset)) in dots
}

forall Vertex u; Vertex v; Link e1; Link e2 where e1 := Edge(u, v); e2 := Edge(u, v) {
  ensure abs(e2.offset - e1.offset) > 2 * num.offset in dots
}

forall Vertex u; Vertex v; Link e1; Link e2 where e1 := Edge(u, v); e2 := Edge(v, u) {
  ensure abs(e1.offset + e2.offset) > 2 * num.offset in dots
}

forall Vertex v; Link e where e := Edge(v, v) {
  e.delta = (? in loops, ? in loops)

  e.arrow = Circle {
    center: v.dot.center + e.delta
    r: num.loopRadius
    strokeWidth: 1
    strokeColor: color.black
    fillColor: none()
  }

  e.arrow below v.dot

  ensure norm(e.delta) == num.loopRadius in loops
}

forall Vertex u; Vertex v; Link e1; Link e2 where e1 := Edge(u, v); e2 := Edge(v, v) {
  encourage maximal(dot(e1.tangent, e2.delta)) in loops
}

forall Vertex u; Vertex v; Link e1; Link e2 where e1 := Edge(v, u); e2 := Edge(v, v) {
  encourage minimal(dot(e1.tangent, e2.delta)) in loops
}

-- we have to duplicate a lot of the above `Edge` code for `Arc`

forall Vertex u; Vertex v; Link e where e := Arc(u, v) {
  a = u.dot.center
  b = v.dot.center
  t = normalize(b - a) -- tangent
  n = rot90(t) -- normal
  m = (a + b) / 2 -- midpoint

  e.tangent = t
  e.offset = ? in dots
  e.arrow = Path {
    d: quadraticCurveFromPoints("open", [a, m + e.offset * n, b])
    strokeColor: color.black
  }

  p = m + (e.offset / 2) * n
  x = num.pointerX
  y = num.pointerY
  e.pointer = Path {
    d: pathFromPoints("closed", [p - x * t + y * n, p + x * t, p - x * t - y * n])
    strokeColor: none()
    fillColor: color.black
  }

  e.arrow below u.dot
  e.arrow below v.dot
  e.pointer below e.arrow

  encourage vdist(u.dot.center, v.dot.center) < num.edgeDist in dots
  encourage minimal(sqr(e.offset)) in dots
}

forall Vertex u; Vertex v; Link e1; Link e2 where e1 := Arc(u, v); e2 := Arc(u, v) {
  ensure abs(e2.offset - e1.offset) > 2 * num.offset in dots
}

forall Vertex u; Vertex v; Link e1; Link e2 where e1 := Arc(u, v); e2 := Arc(v, u) {
  ensure abs(e1.offset + e2.offset) > 2 * num.offset in dots
}

forall Vertex v; Link e where e := Arc(v, v) {
  e.delta = (? in loops, ? in loops)

  e.arrow = Circle {
    center: v.dot.center + e.delta
    r: num.loopRadius
    strokeWidth: 1
    strokeColor: color.black
    fillColor: none()
  }

  n = normalize(e.delta)
  t = rot90(n)

  p = v.dot.center + 2 * e.delta
  x = num.pointerX
  y = num.pointerY
  e.pointer = Path {
    d: pathFromPoints("closed", [p - x * t + y * n, p + x * t, p - x * t - y * n])
    strokeColor: none()
    fillColor: color.black
  }

  e.arrow below v.dot

  ensure norm(e.delta) == num.loopRadius in loops
}

forall Vertex u; Vertex v; Link e1; Link e2 where e1 := Arc(u, v); e2 := Arc(v, v) {
  encourage maximal(dot(e1.tangent, e2.delta)) in loops
}

forall Vertex u; Vertex v; Link e1; Link e2 where e1 := Arc(v, u); e2 := Arc(v, v) {
  encourage minimal(dot(e1.tangent, e2.delta)) in loops
}
