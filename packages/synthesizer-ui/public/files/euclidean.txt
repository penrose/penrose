canvas {
  width = 800
  height = 700
}

Colors {
    -- Keenan palette
    black = rgba(0.0, 0.0, 0.0, 1.0)

    darkpurple = rgba(0.549,0.565,0.757, 1.0)
    purple2 = rgba(0.106, 0.122, 0.54, 0.2)
    lightpurple = rgba(0.816,0.824, 0.902, 1.0)

    verylightpurple = rgba(0.953, 0.957, 0.977, 1.0)
    purple3 = rgba(0.557, 0.627, 0.769, 1.0)

    midnightblue = rgba(0.14, 0.16, 0.52, 1.0)
    lightslategray = rgba(0.50, 0.51, 0.69, 1.0)
    silver = rgba(0.71, 0.72, 0.79, 1.0)
    gainsboro = rgba(0.87, 0.87, 0.87, 1.0)

    darkgray = rgba(0.1, 0.1, 0.1, 1.0)
    mediumgray = rgba(0.5, 0.5, 0.5, 1.0)
    gray = rgba(0.8, 0.8, 0.8, 1.0)
    red = rgba(1.0, 0.0, 0.0, 1.0)
    pink = rgba(1.0, 0.4, 0.7, 1.0)
    yellow = rgba(1.0, 1.0, 0.0, 1.0)
    orange = rgba(1.0, 0.6, 0.0, 1.0)
    lightorange = rgba(1.0, 0.6, 0.0, 0.25)
    green = rgba(0.0, 1.0, 0.0, 1.0)
    blue = rgba(0.0, 0.0, 1.0, 1.0)
    sky = rgba(0.325, 0.718, 0.769, 1.0)
    lightsky = rgba(0.325, 0.718, 0.769, 0.25)
    lightblue = rgba(0.0, 0.0, 1.0, 0.25)
    cyan = rgba(0.0, 1.0, 1.0, 1.0)
    purple = rgba(0.5, 0.0, 0.5, 1.0)
    white = rgba(1.0, 1.0, 1.0, 1.0)
    none = rgba(0.0, 0.0, 0.0, 0.0)
    bluegreen = rgba(0.44, 0.68, 0.60, 1.0)
}

const {
    pi = 3.14159
    arrowheadSize = 0.65
    strokeWidth = 1.75
    textPadding = 7.0
    textPadding2 = 25.0
    repelWeight = 0.7 -- TODO: Reverted from 0.0
    repelWeight2 = 0.5
    fontSize = "18pt"
    containPadding = 50.0
    rayLength = 100.0
    pointSize = 4.0
    pointStroke = 0.0
    thetaRadius = 30.0
    bigThetaRadius = 40.0
}

Plane p {
  dim = 700.0
  p.text = Text {
    center : ((dim / 2.0) - const.textPadding2, (dim / 2.0) - const.textPadding2)
    string : p.label
    fontSize : const.fontSize
  }

  -- inner: #f3f4f9, outer: #8e93c4
  p.icon = Rectangle {
    -- angle : 0.0
    --color : Colors.verylightpurple
    color : Colors.none -- TODO: arrange angle markers so plane can be opaque
    strokeColor : Colors.purple3
    strokeWidth : 2.0
    center : (0.0, 0.0)
    w : dim
    h : dim
  }

  p.text above p.icon
}

Point p {
  p.x = ?
  p.y = ?
  p.vec = (p.x, p.y)
  p.color = Colors.black

    p.icon = Circle {
      center: p.vec
      r : const.pointSize
      color : Colors.black
      strokeWidth : 0.0
      strokeColor : Colors.black
    }

    p.text = Text {
      string : p.label
      rotation : 0.0
      color : Colors.black
      fontSize : const.fontSize
    }
    ensure atDist(p.icon, p.text, const.textPadding)
}

Point p
with Plane P
where In(p, P) {
  -- TODO: the problem is that this ensures the padding is const? Or is > padding okay?
  -- There's a choice of whether to put padding on the point or the text for containment
  ensure contains(P.icon, p.icon, const.containPadding)
  ensure contains(P.icon, p.text, 0.0)

  p.icon above P.icon
  p.text above P.icon
}

Point p, q, r
where Collinear(p, q, r) {
  ensure collinear(p.icon, q.icon, r.icon)
  encourage repel(p.icon, q.icon, const.repelWeight)
  encourage repel(q.icon, r.icon, const.repelWeight)
--  encourage equal(vdist(q.vec, p.vec), vdist(r.vec,q.vec))
}

Segment e
where e := MkSegment(p, q)
with Point p; Point q {
     e.vec = [q.x - p.x, q.y - p.y]

     e.color = Colors.black

     e.icon = Line {
       start : p.icon.center
       end : q.icon.center
	     color : e.color
	     thickness : const.strokeWidth
	     stroke : "none"
	     style : "solid"
     }

     p.icon above e.icon
     q.icon above e.icon

     encourage pointLineDist(p.text.center, e.icon, 30.)
     encourage pointLineDist(q.text.center, e.icon, 30.)

    --  e.icon above const.plane
}

Segment s, t
where EqualLength(s, t) {
  encourage equal(vdist(s.icon.start, s.icon.end), vdist(t.icon.start, t.icon.end))
}

Segment s, t 
where EqualLengthMarker(s, t) {
  s.tick = Line {
    start : midpointOffset(s.icon, 10.)
    end : midpointOffset(s.icon, -10.)
    color : Colors.black
    thickness : 2.0
    stroke : "none"
    style : "solid"
  }
  t.tick = Line {
    start : midpointOffset(t.icon, 10.)
    end : midpointOffset(t.icon, -10.)
    color : Colors.black
    thickness : 2.0
    stroke : "none"
    style : "solid"
  }
  s.tick above s.icon
  t.tick above t.icon
}

Angle a, b
where EqualAngleMarker1(a, b) {
  --find points from p->q, then q->r for each vector. draw vectors for each
  startA = ptOnLine(a.q, a.p, a.radius)
  endA = ptOnLine(a.q, a.r, a.radius)
  sweepA = arcSweepFlag(a.q, startA, endA)

  startB = ptOnLine(b.q, b.p, b.radius)
  endB = ptOnLine(b.q, b.r, b.radius)
  sweepB = arcSweepFlag(b.q, startB, endB)

  override a.mark = Path {
    pathData : arc("open", startA, endA, (a.radius, a.radius), 0, 0, sweepA)
   strokeWidth : 2.0
    color : Colors.black
    fill: Colors.none
 }
  override b.mark = Path {
    pathData : arc("open", startB, endB, (b.radius, b.radius), 0, 0, sweepB)
    strokeWidth : 2.0
    color : Colors.black
    fill: Colors.none
 }
}

Angle a, b
where EqualAngleMarker2(a, b) {
  startA = ptOnLine(a.q, a.p, a.radius)
  endA = ptOnLine(a.q, a.r, a.radius)
  sweepA = arcSweepFlag(a.q, startA, endA)

  startB = ptOnLine(b.q, b.p, b.radius)
  endB = ptOnLine(b.q, b.r, b.radius)
  sweepB = arcSweepFlag(b.q, startB, endB)

  override a.mark = Path {
    pathData : arc("open", startA, endA, (a.radius, a.radius), 0, 0, sweepA)
   strokeWidth : 2.0
    color : Colors.black
    fill: Colors.none
 }
  override b.mark = Path {
    pathData : arc("open", startB, endB, (b.radius, b.radius), 0, 0, sweepB)
    strokeWidth : 2.0
    color : Colors.black
    fill: Colors.none
 }

  bigR = const.bigThetaRadius
  startAbig = ptOnLine(a.q, a.p, bigR)
  endAbig = ptOnLine(a.q, a.r, bigR)

  startBbig = ptOnLine(b.q, b.p, bigR)
  endBbig = ptOnLine(b.q, b.r, bigR)

  override a.mark2 = Path {
    pathData : arc("open", startAbig, endAbig, (bigR, bigR), 0, 0, sweepA)
    strokeWidth : 2.0
    color : Colors.black
    fill: Colors.none
 }
  override b.mark2 = Path {
    pathData : arc("open", startBbig, endBbig, (bigR, bigR), 0, 0, sweepB)
    strokeWidth : 2.0
    color : Colors.black
    fill: Colors.none
 }

}
Angle a, b
where EqualAngle(a, b) {
  -- make sure angle a is equal to angle b
  dotA = dot(normalize(a.p - a.q), normalize(a.r - a.q))
  dotB = dot(normalize(b.p - b.q), normalize(b.r - b.q))
  ensure equal(dotA, dotB)
}

Angle a
where RightUnmarked(a) {
  ensure equal(dot(a.p - a.q, a.r - a.q), 0)
}

Angle a
where RightMarked(a) {
  --render half square path of size a.radius
  override a.mark = Path {
    pathData : pathFromPoints("open", [ptOnLine(a.q, a.p, 20.), innerPointOffset(a.q, a.p, a.r, 20.), ptOnLine(a.q, a.r, 20.)])
    strokeWidth : 2.0
    color : Colors.black
    fill : Colors.none
  }
  ensure equal(dot(a.p - a.q, a.r - a.q), 0)
}

Segment e; Plane p {
  e.icon above p.icon
}

Triangle t; Plane P 
where t := MkTriangle(p, q, r)
with Point p; Point q; Point r {
  t.side1 above P.icon
  t.side2 above P.icon
  t.side3 above P.icon
}

Triangle t
where t := MkTriangle(p, q, r)
with Point p; Point q; Point r {
     t.color = setOpacity(Colors.darkpurple, 0.4)
     t.side1 = Line {
     	 start : p.icon.center
     	 end : q.icon.center
	     color : t.color
	     thickness : const.strokeWidth
	     stroke : "none"
	     style : "solid"
     }
     t.side2 = Line {
       start : q.icon.center
       end : r.icon.center
	     color : t.color
	     thickness : const.strokeWidth
	     stroke : "none"
	     style : "solid"
     }
     t.side3 = Line {
     	 start : p.icon.center
     	 end : r.icon.center
	     color : t.color
	     thickness : const.strokeWidth
	     stroke : "none"
	     style : "solid"
     }
}

-- -- Should the rectangle be constructed from the points, or vice versa?
Rectangle R
where R := MkRectangle(p, q, r, s); In(p, P)
with Point p; Point q; Point r; Point s; Plane P  {
  override R.color = setOpacity(Colors.blue, 0.2)

  R.icon = Path {
    pathData : pathFromPoints("closed", [p.icon.center, q.icon.center, r.icon.center, s.icon.center])
    strokeWidth : const.strokeWidth
    fill : R.color
    color : Colors.black
  }

  ensure equal(vdist(p.icon.center, q.icon.center), vdist(r.icon.center, s.icon.center))
  ensure equal(vdist(p.icon.center, s.icon.center), vdist(q.icon.center, r.icon.center))
  ensure equal(vdist(p.icon.center, s.icon.center), vdist(q.icon.center, r.icon.center))
  ensure equal(dot(p.icon.center - q.icon.center, q.icon.center - r.icon.center), 0)
  ensure equal(dot(q.icon.center - r.icon.center, r.icon.center - s.icon.center), 0)
  -- ensure lessThan(10.0, norm(p.icon.center - q.icon.center))
  -- ensure lessThan(10.0, norm(q.icon.center - r.icon.center))

  R.icon above P.icon
}

Angle theta
where theta := InteriorAngle(p, q, r)
with Point p; Point q; Point r {
  theta.p = p.vec
  theta.q = q.vec
  theta.r = r.vec
  theta.color = Colors.black
  theta.side1 = Line {
    start : p.icon.center
    end : q.icon.center
    color : theta.color
    thickness : const.strokeWidth
    stroke : 2.
    style : "solid"
  }
  theta.side2 = Line {
    start : q.icon.center
    end : r.icon.center
    color : theta.color
    thickness : const.strokeWidth
    stroke : 2.
    style : "solid"
  }
  theta.radius = const.thetaRadius
  encourage nonDegenerateAngle(p.icon, q.icon, r.icon)
}