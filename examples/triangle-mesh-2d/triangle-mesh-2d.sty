canvas {
   width = 360
   height = 270
}

Colors {
   color black = rgba(0.,0.,0.,1.)
   color red = rgba(1.,0.,0.,1.)
   color green = rgba(0.,.7,0.,1.)
   color blue = rgba(0.,0,1.,1.)
   color white = rgba(1.,1.,1.,1.)
   color lightGray = rgba(.8,.8,.8,1.)
   color clear = rgba(0.,0.,0.,0.)
   color semiBlue = rgba( 27./255., 31./255., 138./255., .2 )
}

Global {
   scalar vertexRadius = 1.75
   scalar pointRadius = 2.0
   scalar lineThickness = 1.
   scalar labelBoundRadius = 8.
   scalar lineOffset = 8.0

   shape box = Rectangle {
      center: (0.,0.)
      color: Colors.clear
      strokeColor: Colors.lightGray
      strokeWidth: 2.
      w: canvas.width
      h: canvas.height
   }

   string fontFamily = "Palatino"
   string fontSize = "9pt"
}

forall Vertex v {

   vec2 v.center = (?,?)

   -- black dot
   shape v.icon = Circle {
      color: Colors.black
      r: Global.vertexRadius
      center: v.center
   }

   v.labelAngle = ?
   v.labelRadius = ?

   -- label
   shape v.text = Text {
      center: v.icon.center + v.labelRadius*( cos(v.labelAngle), sin(v.labelAngle ) )
      string: v.label
      fontFamily: Global.fontFamily
      fontSize: Global.fontSize
      fontStyle: "italic"
      color: Colors.black
   }

   -- make sure label doesn't get too far from the dot
   ensure inRange( v.labelRadius, 1.02*Global.labelBoundRadius, 1.1*Global.labelBoundRadius )

   -- invisible circle around label
   -- (used to prevent overlap)
   -- TODO we should really stop hacking
   -- TODO this, and just get bounding
   -- TODO boxes working for Text...
   shape v.bounds = Circle {
      center: v.text.center
      r: Global.labelBoundRadius
      color: none()
   }

   -- make sure the dot and label are both
   -- on the canvas
   ensure contains( Global.box, v.icon )
   ensure contains( Global.box, v.bounds )

   -- keep the label near the dot
   encourage equal( norm(v.text.center - v.icon.center), Global.labelBoundRadius )
}

-- make sure vertex labels don't overlap
forall Vertex u; Vertex v {
   ensure disjoint( u.bounds, v.bounds )
}

forall Edge e; Vertex i; Vertex j
where e := MakeEdge(i,j) {

   -- grab edge endpoints
   vec2 pi = i.icon.center
   vec2 pj = j.icon.center
   
   -- black line between endpoints
   shape e.segment = Line {
      start: pi
      end: pj
      color: Colors.black
      thickness: Global.lineThickness
   }

   -- -- (DEBUG) draw full line through segment
   -- vec2 m = (pi+pj)/2.
   -- shape e.line = Line {
   --    start: m + 100.*(pi-m)
   --    end: m + 100.*(pj-m)
   --    color: rgba( 0., 0., 0., .35 )
   --    thickness: Global.lineThickness
   --    style: "dashed"
   -- }

   -- make sure edge doesn't cover the
   -- labels of its two endpoints
   ensure disjoint( i.bounds, e.segment, 1. )
   ensure disjoint( j.bounds, e.segment, 1. )
}

-- make sure no edge ij covers the label of
-- any other vertex k
forall Edge e; Vertex i; Vertex j; Vertex k
where e := MakeEdge(i,j) {
   
   ensure disjoint( k.bounds, e.segment, 1. )
}

forall Triangle t; Vertex i; Vertex j; Vertex k
where t := MakeTriangle(i,j,k)
{
   vec2 a = i.icon.center
   vec2 b = j.icon.center
   vec2 c = k.icon.center

   -- Define these quantities for each triangle, even
   -- if they're never used, so that they can be easily
   -- referenced by other rules.  (The overhead here is
   -- minimal, especially because we don't need to
   -- differentiate through these quantities unless they
   -- are explicitly incorporated into some later ensure/
   -- encourage statement.
   vec2 t.circumcenter = circumcenter(a,b,c)
   scalar t.circumradius = circumradius(a,b,c)
   vec2 t.incenter = incenter(a,b,c)
   scalar t.inradius = inradius(a,b,c)

   shape t.icon = Path {
      pathData: pathFromPoints("closed", [a,b,c])
      fill: Colors.semiBlue
      color: none()
   }

   -- Make sure triangles are positively
   -- oriented and not tiny, by making their
   -- signed area greater than some fixed constant.
   scalar A = cross2D( b-a, c-a )
   encourage lessThan( 4000., A )

   -- Also ensure triangles are not slivers by making
   -- sure two of their angles are in a reasonable range
   -- (the third will of course make the sum equal to 180)
   scalar aTheta = angleFrom( b-a, c-a )
   scalar bTheta = angleFrom( c-b, a-b )
   ensure inRange( aTheta, toRadians(40.), toRadians(70.) )
   ensure inRange( bTheta, toRadians(30.), toRadians(80.) )

   -- -- Encourage the vertex labels to be outside the triangle
   -- -- by encouraging the total area made with the three
   -- -- vertices to be bigger than the triangle area
   -- vec2 p = i.text.center
   -- vec2 q = j.text.center
   -- vec2 r = k.text.center
   -- scalar Aijk = abs(A)
   -- scalar Apbc = abs( cross2D( b-p, c-p ))
   -- scalar Aapc = abs( cross2D( p-a, c-a ))
   -- scalar Aabp = abs( cross2D( b-a, p-a ))
   -- encourage lessThan( 1.01*Aijk, Apbc+Aapc+Aabp )
   -- scalar Aqbc = abs( cross2D( b-q, c-q ))
   -- scalar Aaqc = abs( cross2D( q-a, c-a ))
   -- scalar Aabq = abs( cross2D( b-a, q-a ))
   -- encourage lessThan( 1.01*Aijk, Aqbc+Aaqc+Aabq )
   -- scalar Arbc = abs( cross2D( b-r, c-r ))
   -- scalar Aarc = abs( cross2D( r-a, c-a ))
   -- scalar Aabr = abs( cross2D( b-a, r-a ))
   -- encourage lessThan( 1.01*Aijk, Arbc+Aarc+Aabr )
}

forall Corner c; Vertex i; Vertex j; Vertex k
where c := MakeCorner(i,j,k) {

   vec2 p = i.center
   vec2 q = j.center
   vec2 r = k.center
   
   scalar s = .35 -- arc radius as fraction of edge length
   scalar R = s*norm(q-p)
   vec2 u = (q-p)/norm(q-p)
   vec2 v = (r-p)/norm(r-p)
   vec2 x = p + R*u
   vec2 y = p + R*v

   shape c.arc = Path {
      fill: none()
      color: Colors.black
      pathData: arc( "open", x, y, (R,R), 0., 0, 0 )
      strokeWidth: .75
   }

   shape c.arcFill = Path {
      fill: none()
      color: none()
      pathData: wedge( i.center, x, y, (R,R), 0., 0, 0 )
      fill: Colors.semiBlue
   }

   scalar R0 = i.bounds.r

   shape c.text = Text {
      string: c.label
      center: p + (R+R0)*unit(u+v)
      fontSize: Global.fontSize
      fontFamily: Global.fontFamily
      fontStyle: "italic"
      color: Colors.black
   }
}

forall Point p {

   vec2 p.center = (?,?)

   -- white dot
   shape p.icon = Circle {
      color: Colors.white
      strokeColor: Colors.black
      r: Global.pointRadius
      center: p.center
      strokeWidth: 1.
   }

   -- label
   shape p.text = Text {
      center: (?,?)
      string: ""
      fontFamily: Global.fontFamily
      fontSize: Global.fontSize
      fontStyle: "italic"
      color: Colors.black
   }

   -- make sure the dot and label are both
   -- on the canvas
   ensure contains( Global.box, p.icon )

   -- keep the label near the dot
   -- encourage equal( norm(p.text.center - p.icon.center), 0. )
}

forall Point p; Triangle t {
   layer p.icon above t.icon
}

-- Barycenter
forall Point p; Triangle t; Vertex i; Vertex j; Vertex k
where t := MakeTriangle(i,j,k); p := Barycenter(t) {
   override p.center = barycenter( i.center, j.center, k.center )
   override p.icon.color = Colors.red
}

-- Circumcenter
forall Point p; Triangle t; Vertex i; Vertex j; Vertex k
where t := MakeTriangle(i,j,k); p := Circumcenter(t) {
   -- put point at circumcenter 
   override p.center = t.circumcenter
}

-- Circumcircle
forall Circle C; Triangle t; Vertex i; Vertex j; Vertex k
where t := MakeTriangle(i,j,k); C := Circumcircle(t) {

   shape C.icon = Circle {
      center: t.circumcenter
      r: t.circumradius
      color: none()
      strokeColor: rgba( 0., 0., 0., .2 )
      strokeWidth: 1.5
      -- strokeStyle: "dashed"
   }
}

-- Incenter
forall Point p; Triangle t; Vertex i; Vertex j; Vertex k
where t := MakeTriangle(i,j,k); p := Incenter(t) {

   -- put point at incenter 
   override p.center = t.incenter
}

-- Incircle
forall Circle C; Triangle t; Vertex i; Vertex j; Vertex k
where t := MakeTriangle(i,j,k); C := Incircle(t) {
   
   shape C.icon = Circle {
      center: t.incenter
      r: t.inradius
      color: none()
      strokeColor: rgba( 0., 0., 0., .2 )
      strokeWidth: 1.5
      --strokeStyle: "dashed"
   }
}

forall DualEdge d; Triangle t1; Triangle t2
where d := MakeDualEdge(t1,t2) {

   shape d.segment = Line {
      start: t1.circumcenter
      end: t2.circumcenter
      color: Colors.black
      thickness: Global.lineThickness
      style: "dashed"
      strokeDashArray: "4,4"
   }
}

forall Length l; Edge e; Vertex i; Vertex j
where l := EdgeLength(e); e := MakeEdge(i,j) {
   vec2 l.x0 = e.segment.start
   vec2 l.x1 = e.segment.end
}
   
forall Length l; DualEdge d; Triangle s; Triangle t
where l := DualEdgeLength(d); d := MakeDualEdge(s,t) {
   vec2 l.x0 = d.segment.start
   vec2 l.x1 = d.segment.end
}
   
forall Length l {

   vec2 u = unit(l.x1-l.x0)
   vec2 n = -rot90(u)
   scalar w = Global.lineOffset

   scalar l.thickness = .8*Global.lineThickness

   shape l.marker = Line {
      start: l.x0 + w*n
      end: l.x1 + w*n
      color: Colors.black
      thickness: l.thickness
   }
   shape l.end0 = Line {
      start: l.marker.start + .35*w*n
      end: l.marker.start - .35*w*n
      color: Colors.black
      thickness: l.thickness
   }
   shape l.end1 = Line {
      start: l.marker.end + .35*w*n
      end: l.marker.end - .35*w*n
      color: Colors.black
      thickness: l.thickness
   }

   vec2 m = (l.x0+l.x1)/2.
   shape l.text = Equation {
      center: m + 2.*w*n
      string: l.label
      color: Colors.black
      fontSize: Global.fontSize
   }
}

